# -*- coding: utf-8 -*-
"""cleaningRobots.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ad5aRWmT4iVrgmhLaMQBVVqwjI7Ypiqg

Importing of dependencies and libraries
"""

#pip install 'matplotlib==3.3.3'
#pip install agentpy

import seaborn as nsn
import random
import copy
import agentpy as ap 
import numpy as np
import seaborn as sns
import IPython
import matplotlib.pyplot as plt

"""definition of 'Janitor' class"""

class JanitorAgent(ap.Agent):

  def setup(self):
    self.movements = 0
    self.wait = -1

  def action(self):
    location = self.model.room.positions[self]
    if self.model.room_state[location] == 0:
      self.wait = -1
      self.movement()
    else:                          
      if self.wait == -1:
        self.wait = 5
      elif self.wait > 0:
        self.wait -= 1
      else:
        self.model.room_state[location] = 0
        self.wait = -1
  
  def movement(self):
    self.movements += 1
    location = self.model.room.positions[self]
    locationArray = []

    if (location[0] > 0):
      locationArray.append((location[0]-1,location[1]))
      if (location[1] > 0 ):
        locationArray.append((location[0]-1,location[1]-1))
      if (location[1] < self.model.p.N - 1):
        locationArray.append((location[0]-1,location[1]+1))
    if (location[0] < self.model.p.M - 1):
      locationArray.append((location[0]+1,location[1]))
      if (location[1] > 0 ):
        locationArray.append((location[0]+1,location[1]-1))
      if (location[1] < self.model.p.N - 1):
        locationArray.append((location[0]+1,location[1]+1))
    if(location[1] > 0):
      locationArray.append((location[0],location[1]-1))
    if(location[1] < self.model.p.N - 1):
      locationArray.append((location[0],location[1]+1))

    outOfBounds = self.model.room.neighbors(self, 1)
    for adjacent in outOfBounds:
      outOfBoundsPos = self.model.room.positions[adjacent]
      for x in range (len(locationArray)):
        if(locationArray[x] == outOfBoundsPos):
          locationArray.pop(x)
          break
    if(len(locationArray) > 0):
      randInd = random.randint(0, len(locationArray) - 1)
      newPostion = locationArray[randInd]
      self.model.room.move_to(self, newPostion)

class HygieneModel(ap.Model):
  def setup(self):
    self.agents = ap.AgentList(self, self.p.agents, JanitorAgent)
    self.room = ap.Grid(self, [self.p.M, self.p.N], track_empty = True)
    self.room.add_agents(self.agents, random = True, empty = True)
    self.room_state = np.zeros([self.p.M, self.p.N])
    self.notClean = int(self.p.M * self.p.N * self.p.notCleanPercentage)
    accum = 0
    while accum < self.notClean:
      row = self.random.randint(0, self.p.M - 1)
      col = self.random.randint(0, self.p.N - 1)
      if self.room_state[row, col] == 0:
        self.room_state[row, col] = 1
        accum += 1
  def step(self):
    if (np.sum(self.room_state.flatten()) == 0):
      self.stop()
    self.agents.action()
  def update(self):
    self.record('Movements', np.sum(np.array(self.agents.movements)))
    self.record('Non-clean cells', np.sum(self.room_state.flatten()))
  def end(self):
    self.report('Time', 2*self.t)
    self.report('Movements', np.sum(np.array(self.agents.movements)))

parameters = {
    'M' : 15,
    'N': 15,
    'agents' : 5,
    'steps' : 100,
    'seed' : 42,
    'notCleanPercentage' : .3
}

def animationPlot(model, ax):
  myGrid = copy.copy(model.room_state)

  for robot in model.agents:
    myGrid[model.room.positions[robot]] = 2

  color_dict = {0: '#e5e5e5', 1: '#964B00', 2: '#00FFFF'}
  ap.gridplot(myGrid, ax=ax, color_dict=color_dict, convert=True)
  ax.set_title(f"Janitor Agents\n"
              f"step: {model.t*2}\ndirty cells remaining: "
              f"{np.sum(model.room_state).flatten()}")

model = HygieneModel(parameters)
results = model.run()
print(results.reporters)

fig, ax = plt.subplots()
model = HygieneModel(parameters)
animation = ap.animate(model, fig, ax, animationPlot)
IPython.display.HTML(animation.to_jshtml(fps=10))